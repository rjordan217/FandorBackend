# Fandor Backend Challenge

[Heroku link][heroku]

[heroku]: https://fandorbackend.herokuapp.com/

This application is an MVC skeleton backend built in Rails for a film rating and
search website. It is built primarily to deliver content via an API that supports
requests for film data, as well as posting and deleting users, sessions, and ratings.

## Database

This backend is built on a PostgreSQL database, built according to the following schema:

| Model        | Fields*         | Rails Type |
| ------------ | --------------- | ---------- |
| User         | username        | string     |
|              | password_digest | string     |
|              | session_token   | string     |
| Film         | title           | string     |
|              | description     | text       |
|              | url_slug        | string     |
|              | year            | integer    |
| Rating       | film_id         | references |
|              | user_id         | references |
|              | value           | integer    |
| FilmRelation | film1_id        | integer**  |
|              | film2_id        | integer**  |

\* All models have a :created_at and :updated_at field of type "datetime"  
\*\* The Rails "references" data type does not recognize :film1_id and :film2_id as referencing the *films* table, so higher-level validations are added to the models to ensure that both film1 and film2 exist as referenced.

## Models

### Users

User interactions requiring registration or login are built upon the User model.
To first register, users must supply a unique username with only lower- and
uppercase letters, numbers, and underscores, and a password of more than six
characters. Passwords are then "digested" by a Ruby implementation of the BCrypt
algorithm, which manages its own password salts. Thus, safe storage and validation
of user authentication data in the database just requires application of BCrypt
methods. New and already-validated user sessions apply the methods of the User
model to handle login and logout.

### Ratings

Ratings are generated by users for films on an injective basis. The RatingsController
ensures that users are not allowed to post requests on behalf of other users. Ratings
also validate that both their associated :user and :film exist.

### Films and FilmRelations

Films are assumed to be added by the database administrator, so the FilmsController
does not provide any create/destroy actions; however, the presence of a :title,
:year, and :url_slug is validated before saving. Descriptions are assumed to be
optional, and uniqueness is only required for the :url_slug attribute, since many
movies share names, occasionally even being released in the same year. According
to this model, films also have many related films through the FilmRelation model
and the corresponding table. The presence of the associated :film1 and :film2 in
a new FilmRelation is validated before saving. The Film::add_relation method
provides a convenient way to add a new two-way relation.

## Requesting the API

### Endpoints
The following is a list of API endpoints relative to the root directory. The HTTP
request method is listed first, followed by the URI, then optional or required
data, and finally the View rendered by Rails. All responses are returned in JSON
format.
- Session
  + POST '/api/session', \*username and password required\* -renders-> '/api/user/show'
    * Request data structure: {user: {username: \*string\*, password: \*string\*}}
    * Success will reset :session_token in database (and in cookie)
  + DELETE '/api/session' -renders-> '/api/user/show'
    * Successful logout should render a blank user
- User
  + POST '/api/user', \*username and password required\* -renders-> :show
    * Request data structure: {user: {username: \*string\*, password: \*string\*}}
  + GET '/api/user' -renders-> :show
    * Verifies user by :session_token, or returns an "empty" user JSON
  + DELETE '/api/user' -renders-> :show
    * Verifies user by :session_token, then deletes if possible
    * If error occurs, user is still logged out
- Ratings
  + POST '/api/ratings', \*film_id and value required\* -renders-> :show
    * Request data structure: {rating: {film_id: \*integer\*, value: \*integer\*}}
    * :user_id taken from #current_user helper method
  + DELETE '/api/ratings/:id' -renders-> :show
    * Verifies user identity before deleting
- Films
  + GET '/api/films', \*JSON filtering/sorting/pagination data optional\* -renders-> :index
    * For request data structure, see "Filtering, Sorting, and Pagination" below
  + GET '/api/films/:url_slug' -renders-> :show

**Note:** Instead of failing "loudly" (i.e., with a 500 response status), this API
is designed to return an array of errors, which can be handled in a more user-friendly
and informative way.

### Filtering, Sorting, and Pagination

Films can optionally be filtered, sorted, and/or paginated by sending additional
data with the 'GET' request to '/api/films'. The general structure is:  
{  
&nbsp;filters: {  
&nbsp;&nbsp;title: \*string\*,  
&nbsp;&nbsp;description: \*string\*,  
&nbsp;&nbsp;year: \*integer\*,  
&nbsp;&nbsp;*or*  
&nbsp;&nbsp;general: \*string or integer\*  
&nbsp;},  
&nbsp;sort_by: {  
&nbsp;&nbsp;field: \*"title", "description", or "year"\*,  
&nbsp;&nbsp;by: \*"asc", "desc", or not present\*  
&nbsp;},  
&nbsp;limit: \*integer\*,  
&nbsp;page_number: \*integer\*  
}

**Notes:**
- Valid field values are given.
- Both :limit and :page_number are required for pagination.
- Searches for "title" and "description" are case insensitive. If a "general"
filter is applied, films with titles, descriptions, or years matching the supplied
parameter returned.

## Future Possibilities

The Video on Demand market is a rich area for development of user-friendly websites.
Features like recommendation systems built on the principles of machine learning
allow sites like Netflix to make eerily adept new film suggestions to their users.
Data analyses could be performed on user ratings to quickly calculate and serve up
these suggestions.

Of course, in the more immediate future, the search options could be greatly
expanded to check for common misspellings. A cache system like Redis or Memcached
could also be added to deliver content more quickly (and should certainly be added
once the database reaches a much larger size). Depending on how large the user
and film base becomes, the database may need to be migrated from a RDBMS to a
NoSQL option.
